package scaffold

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/gruntwork-io/terragrunt/config"
	"github.com/gruntwork-io/terragrunt/shell"

	"github.com/gruntwork-io/terragrunt/terraform"

	"github.com/gruntwork-io/terragrunt/cli/commands/hclfmt"
	"github.com/gruntwork-io/terragrunt/util"

	boilerplate_options "github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/templates"
	"github.com/gruntwork-io/boilerplate/variables"
	"github.com/gruntwork-io/go-commons/errors"
	"github.com/gruntwork-io/terragrunt/options"
	"github.com/gruntwork-io/terratest/modules/files"
	"github.com/hashicorp/go-getter"
)

const (
	SourceUrlTypeHttps = "git-https"
	SourceUrlTypeGit   = "git-ssh"
	SourceGitSshUser   = "git"

	defaultBoilerplateConfig = `
variables:

`
	defaultTerragruntTemplate = `
# This is a Terragrunt module generated by boilerplate.
terraform {
  source = "{{ .sourceUrl }}"
}

inputs = {
  # --------------------------------------------------------------------------------------------------------------------
  # Required input variables
  # --------------------------------------------------------------------------------------------------------------------
  {{ range .requiredVariables }}
  # Description: {{ .Description }}
  # Type: {{ .Type }}
  {{ .Name }} = {{ .DefaultValuePlaceholder }}  # TODO: fill in value
  {{ end }}

  # --------------------------------------------------------------------------------------------------------------------
  # Optional input variables
  # Uncomment the ones you wish to set
  # --------------------------------------------------------------------------------------------------------------------
  {{ range .optionalVariables }}
  # Description: {{ .Description }}
  # Type: {{ .Type }}
  # {{ .Name }} = {{ .DefaultValue }}
  {{ end }}
}
`
)

func Run(opts *options.TerragruntOptions) error {
	// download remote repo to local
	moduleUrl := ""
	templateUrl := ""
	if len(opts.TerraformCliArgs) >= 2 {
		moduleUrl = opts.TerraformCliArgs[1]
	}

	if len(opts.TerraformCliArgs) >= 3 {
		templateUrl = opts.TerraformCliArgs[2]
	}

	tempDir, err := os.MkdirTemp("", "scaffold")
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// prepare inputs
	vars, err := variables.ParseVars(opts.ScaffoldVars, opts.ScaffoldVarFiles)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// prepare source url

	parsedModuleUrl, err := terraform.ToSourceUrl(moduleUrl, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}
	moduleUrl = parsedModuleUrl.String()

	sourceUrlType := SourceUrlTypeHttps
	if value, found := vars["SourceUrlType"]; found {
		sourceUrlType = fmt.Sprintf("%s", value)
	}

	scheme, host, path := parseUrl(opts, moduleUrl)
	// try to rewrite module url if is https and is requested to be git
	if scheme != "" {
		if scheme == "https" && sourceUrlType == SourceUrlTypeGit {
			// TODO: handle git -> https
			gitUser := SourceGitSshUser
			if value, found := vars["SourceGitSshUser"]; found {
				gitUser = fmt.Sprintf("%s", value)
			}
			if strings.HasPrefix(path, "/") {
				path = path[1:]
			}

			moduleUrl = fmt.Sprintf("%s@%s:%s", gitUser, host, path)
		}
	}

	parsedModuleUrl, err = terraform.ToSourceUrl(moduleUrl, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	params := parsedModuleUrl.Query()
	refReplacement, refVarPassed := vars["Ref"]
	if refVarPassed {
		params.Set("ref", fmt.Sprintf("%s", refReplacement))
		parsedModuleUrl.RawQuery = params.Encode()
	}
	ref := params.Get("ref")
	if ref == "" {
		rootSourceUrl, _, err := terraform.SplitSourceUrl(parsedModuleUrl, opts.Logger)
		if err != nil {
			return errors.WithStackTrace(err)
		}

		tag, err := shell.GitLastReleaseTag(opts, rootSourceUrl)
		if err == nil {
			params.Add("ref", tag)
			parsedModuleUrl.RawQuery = params.Encode()
		}
	}

	moduleUrl = parsedModuleUrl.String()
	opts.Logger.Infof("Scaffolding a new Terragrunt module %s %s to %s", parsedModuleUrl.String(), templateUrl, opts.WorkingDir)

	if err := getter.GetAny(tempDir, parsedModuleUrl.String()); err != nil {
		return errors.WithStackTrace(err)
	}
	if err != nil {
		return errors.WithStackTrace(err)
	}

	templateDir := ""
	if templateUrl != "" {
		parsedTemplateUrl, err := terraform.ToSourceUrl(templateUrl, tempDir)

		params := parsedTemplateUrl.Query()
		ref := params.Get("ref")
		if ref == "" {
			rootSourceUrl, _, err := terraform.SplitSourceUrl(parsedTemplateUrl, opts.Logger)
			if err != nil {
				return errors.WithStackTrace(err)
			}

			tag, err := shell.GitLastReleaseTag(opts, rootSourceUrl)
			if err == nil {
				params.Add("ref", tag)
				parsedTemplateUrl.RawQuery = params.Encode()
			}
		}

		templateDir, err = os.MkdirTemp("", "templateDir")
		if err != nil {
			return errors.WithStackTrace(err)
		}
		opts.Logger.Infof("Using template from %s as boilerplate", parsedTemplateUrl.String())

		err = getter.GetAny(templateDir, parsedTemplateUrl.String())
		if err != nil {
			return errors.WithStackTrace(err)
		}
	}

	inputs, err := config.ParseVariables(opts, tempDir)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// run boilerplate

	// prepare boilerplate dir
	boilerplateDir := util.JoinPath(tempDir, util.DefaultBoilerplateDir)

	// use template dir as boilerplate dir
	if templateDir != "" {
		boilerplateDir = templateDir
	}

	if !files.IsExistingDir(boilerplateDir) {
		// no default boilerplate dir, create one
		boilerplateDir, err = os.MkdirTemp("", "scaffold")
		if err != nil {
			return errors.WithStackTrace(err)
		}
		err = os.WriteFile(util.JoinPath(boilerplateDir, "terragrunt.hcl"), []byte(defaultTerragruntTemplate), 0644)
		if err != nil {
			return errors.WithStackTrace(err)
		}
		err = os.WriteFile(util.JoinPath(boilerplateDir, "boilerplate.yml"), []byte(defaultBoilerplateConfig), 0644)
		if err != nil {
			return errors.WithStackTrace(err)
		}
	}

	// separate inputs that require value and with default value
	var requiredVariables []*config.ParsedVariable
	var optionalVariables []*config.ParsedVariable

	for _, value := range inputs {
		if value.DefaultValue == "" {
			requiredVariables = append(requiredVariables, value)
		} else {
			optionalVariables = append(optionalVariables, value)
		}
	}

	vars["requiredVariables"] = requiredVariables
	vars["optionalVariables"] = optionalVariables

	vars["sourceUrl"] = moduleUrl

	opts.Logger.Infof("Running boilerplate in %s", opts.WorkingDir)
	boilerplateOpts := &boilerplate_options.BoilerplateOptions{
		TemplateFolder:  boilerplateDir,
		OutputFolder:    opts.WorkingDir,
		OnMissingKey:    boilerplate_options.DefaultMissingKeyAction,
		OnMissingConfig: boilerplate_options.DefaultMissingConfigAction,
		Vars:            vars,

		NonInteractive: true,
	}
	emptyDep := variables.Dependency{}
	err = templates.ProcessTemplate(boilerplateOpts, boilerplateOpts, emptyDep)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	// running fmt
	err = hclfmt.Run(opts)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	return nil
}

func parseUrl(opts *options.TerragruntOptions, moduleUrl string) (string, string, string) {
	pattern := `git::([^:]+)://([^/]+)(/.*)`

	re := regexp.MustCompile(pattern)

	matches := re.FindStringSubmatch(moduleUrl)
	if len(matches) != 4 {
		opts.Logger.Warnf("Failed to parse module url %s", moduleUrl)
		return "", "", ""
	}

	scheme := matches[1]
	host := matches[2]
	path := matches[3]

	return scheme, host, path
}
